# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'fer_15_3_2021.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
# Facial Feedback system of e-learning using FER

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtChart import *
import cv2
import datetime
import os.path

from numpy.core.numeric import outer

import pandas as pd
import numpy as np

from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras.losses import categorical_crossentropy
from keras.optimizers import Adam
from keras.utils import np_utils
from tensorflow._api.v2 import train






class Ui_trainWindow(QDialog):
    def __init__(self, *args, **kwargs):
        super(Ui_trainWindow, self).__init__(*args, **kwargs)
        
        self.setObjectName("self")       
        self.resize(1240, 480)
        self.setMinimumSize(QtCore.QSize(0, 0))
        self.setMaximumSize(QtCore.QSize(1240, 480))
        font = QtGui.QFont()
        font.setFamily("Calibri")
        font.setBold(True)
        font.setWeight(85)
        self.setFont(font)
        self.second = None
        self.csvFile=""
        self.eporch = 1

        #self.imgLabel = QtWidgets.QLabel(self)
        #self.imgLabel.setGeometry(QtCore.QRect(320, 20, 600, 300))
        #self.imgLabel.setMaximumSize(QtCore.QSize(600, 300))
        #self.imgLabel.setText("")
        #self.imgLabel.setObjectName("imgLabel")
        #self.coverImg=cv2.imread("c3.jpg")

        #self.displayImage(self.coverImg, 1)

        self.horizontalLayoutWidget = QtWidgets.QWidget(self)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(120, 180, 1000, 100))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")

        self.choosebutton = QtWidgets.QPushButton(self.horizontalLayoutWidget)
        self.choosebutton.setObjectName("choosebutton")
        self.choosebutton.clicked.connect(self.chooseFile)
        self.horizontalLayout.addWidget(self.choosebutton)

        self.startbutton = QtWidgets.QPushButton(self.horizontalLayoutWidget)
        self.startbutton.setObjectName("startbutton")
        self.startbutton.clicked.connect(self.train_mode)
        self.horizontalLayout.addWidget(self.startbutton)

        self.eporchbutton = QtWidgets.QPushButton(self.horizontalLayoutWidget)
        self.eporchbutton.setObjectName("startbutton")
        self.eporchbutton.clicked.connect(self.getInteger)
        self.horizontalLayout.addWidget(self.eporchbutton)
        
        self.exitbutton = QtWidgets.QPushButton(self.horizontalLayoutWidget)
        self.exitbutton.setObjectName("startbutton")
        self.exitbutton.clicked.connect(self.exitButton_)
        self.horizontalLayout.addWidget(self.exitbutton)

        self.result = QtWidgets.QLabel(self)
        self.result.setGeometry(QtCore.QRect(260, 230, 400, 181))
        self.result.setObjectName("result")

        self.retranslateUi()

    def exitButton_(self):
        self.hide()
	
    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate("self", "Train Window"))
        self.choosebutton.setText(_translate("self", "Chose CSV file to train"))
        self.startbutton.setText(_translate("self", "Run Train"))
        self.eporchbutton.setText(_translate("self", "Set Eporch"))
        self.exitbutton.setText(_translate("self", "Exit"))
        self.result.setText(_translate("self", "Progress will be shown here..."))
        
           
    def getInteger(self):
        i, okPressed = QInputDialog.getInt(self, "Get integer","Eporch Count:", 1, 0, 100, 10)
        if okPressed:
            self.eporch = i
            print(i)
        
    def chooseFile(self):
		#file choosing
        print('getting...') 
        self.csvFile=""
        self.csvFile, dummy = QFileDialog.getOpenFileName(self.choosebutton, "open csv file.", '~/desktop', "video files (*.csv)")
	   


    def train_mode(self):
        if(self.csvFile==""):
            self.result.setText("No selected CSV file.\nSelect a csv file first.")
            print("No File")
            return
        _translate = QtCore.QCoreApplication.translate

        strr = "File reading is in progress ... "

        self.result.setText( strr)

        df = pd.read_csv(self.csvFile)

        # Dataset info.
        # 3 column (emotion(0-6), pixels, usage)
        print(df.info())

        # usage gives us how many data are for Training, PublicTest and PrivateTest
        # Training       28709
        # PublicTest      3589
        # PrivateTest     3589
        print(df["Usage"].value_counts())

        # lets see some data, to better understand data format
        print(df.head())

        X_train, train_y, X_test, test_y = [], [], [], []

        # now go through all the data
        # if usage = 'Training' use it as a Training data
        # if usage = 'PublicTest' use that data as a Test data
        for index, row in df.iterrows():
            val = row['pixels'].split(" ")
            try:
                if 'Training' in row['Usage']:
                    X_train.append(np.array(val, 'float32'))
                    train_y.append(row['emotion'])
                elif 'PublicTest' in row['Usage']:
                    X_test.append(np.array(val, 'float32'))
                    test_y.append(row['emotion'])
            except:
                print(f"error occurred at index :{index} and row:{row}")

       
        #strr = strr+ "\nFile reading is Completed ... "
        #self.result.setText(strr)

        num_features = 64
        # num_labels use to detect emotion(0-6)
        num_labels = 7
        batch_size = 64
        epochs = self.eporch
        width, height = 48, 48

       
        X_train = np.array(X_train, 'float32')
        train_y = np.array(train_y, 'float32')
        X_test = np.array(X_test, 'float32')
        test_y = np.array(test_y, 'float32')


        # Normalization 0 to 1
        X_train -= np.mean(X_train, axis=0)
        X_train /= np.std(X_train, axis=0)

        X_test -= np.mean(X_test, axis=0)
        X_test /= np.std(X_test, axis=0)

        X_train = X_train.reshape(X_train.shape[0], width, height, 1)
        X_test = X_test.reshape(X_test.shape[0], width, height, 1)
        print(f"shape:{X_train.shape}")

        # As we are going use 'categorical_crossentropy' to compile the model
        #   so we need to change train_y and test_y accordingly

        # what np_utils.to_categorical do?
        #   we have values from 0 to 6 in int format,
        #   np_utils.to_categorical will convert those values in matrix format, in such way that most suitable for
        #   categorical_crossentropy function
        train_y = np_utils.to_categorical(train_y, num_classes=num_labels)
        test_y = np_utils.to_categorical(test_y, num_classes=num_labels)


        #                   designing the cnn                   #

        # 1st convolution layer

        #strr= strr+"\nCreating CNN Model ... "
        #self.result.setText(strr)


        model = Sequential()
        # X_train.shape[1:], 0 index gives us the position of that data sample, so we don't need that
        model.add(Conv2D(64, kernel_size=(3, 3), activation='relu', input_shape=(X_train.shape[1:])))
        model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
        # model.add(BatchNormalization())
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
        # Dropout,
        #   randomly drop some data from output of this layer, so that model don't over fit
        model.add(Dropout(0.5))

        # 2nd convolution layer
        model.add(Conv2D(64, (3, 3), activation='relu'))
        model.add(Conv2D(64, (3, 3), activation='relu'))
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
        model.add(Dropout(0.5))

        # 3rd convolution layer
        model.add(Conv2D(128, (3, 3), activation='relu'))
        model.add(Conv2D(128, (3, 3), activation='relu'))
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

        model.add(Flatten())

        # fully connected neural networks
        model.add(Dense(1024, activation='relu'))
        model.add(Dropout(0.2))
        model.add(Dense(1024, activation='relu'))
        model.add(Dropout(0.2))

        # activation = 'softmax'
        #   as we are doing multi class classification
        model.add(Dense(num_labels, activation='softmax'))

        # model.summary()
        #                   Compiling the model                 #
        # optimizer = Adam() as it is multiclass classification #
        #strr = strr + "\n Compiling the model ... "
        #self.result.setText(strr)
        model.compile(loss=categorical_crossentropy, 
                    optimizer=Adam(),
                    metrics=['accuracy'])

        # Training the model

        #strr = strr+"\nTraining the model...."
        
        #self.result.setText( strr)
        
        model.fit(X_train, train_y,
                batch_size=batch_size,
                epochs=self.eporch,
                verbose=1,
                validation_data=(X_test, test_y),
                shuffle=True)
                
        
        #self.result.setText(_translate("self", "Trained succusseful..."))

        #                   Saving the model                    #
        fer_json = model.to_json()
        with open("fer.json", "w") as json_file:
            json_file.write(fer_json)
        model.save_weights("fer.h5")

        strr=strr+"\nModel Trained succussefully..."
        self.result.setText(strr)
